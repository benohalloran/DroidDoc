{"methods":["SpannableStringBuilder append(CharSequence text, Object what, int flags) Appends the character sequence text and spans what over the appended part.","SpannableStringBuilder append(char text) Convenience for append(String.valueOf(text)).","SpannableStringBuilder append(CharSequence text, int start, int end) Convenience for replace(length(), length(), text, start, end)","SpannableStringBuilder append(CharSequence text) Convenience for replace(length(), length(), text, 0, text.length())","char charAt(int where) Return the char at the specified offset within the buffer.","void clear() Convenience for replace(0, length(), \"\", 0, 0)","void clearSpans() Removes all spans from the Editable, as if by calling removeSpan(Object) on each of them.","SpannableStringBuilder delete(int start, int end) Convenience for replace(st, en, \"\", 0, 0)","abstract void drawText(Canvas c, int start, int end, float x, float y, Paint p) Just like drawText(char[], int, int, float, float, Paint).","boolean equals(Object o) Compares this instance with the specified object and indicates if they are equal.","void getChars(int start, int end, char[] dest, int destoff) Copy the specified range of chars from this buffer into the specified array, beginning at the specified offset.","InputFilter[] getFilters() Returns the array of input filters that are currently applied to changes to this Editable.","int getSpanEnd(Object what) Return the buffer offset of the end of the specified markup object, or -1 if it is not attached to this buffer.","int getSpanFlags(Object what) Return the flags of the end of the specified markup object, or 0 if it is not attached to this buffer.","int getSpanStart(Object what) Return the buffer offset of the beginning of the specified markup object, or -1 if it is not attached to this buffer.","<T> T[] getSpans(int queryStart, int queryEnd, Class<T> kind) Return an array of the spans of the specified type that overlap the specified range of the buffer.","int getTextRunCursor(int contextStart, int contextEnd, int dir, int offset, int cursorOpt, Paint p) This method was deprecated in API level 12. This is an internal method, refrain from using it in your code","abstract int getTextWidths(int start, int end, float[] widths, Paint p) Just like getTextWidths(char[], int, int, float[]).","int hashCode() Returns an integer hash code for this object.","SpannableStringBuilder insert(int where, CharSequence tb, int start, int end) Convenience for replace(where, where, text, start, end)","SpannableStringBuilder insert(int where, CharSequence tb) Convenience for replace(where, where, text, 0, text.length());","int length() Return the number of chars in the buffer.","abstract float measureText(int start, int end, Paint p) Just like measureText(char[], int, int).","int nextSpanTransition(int start, int limit, Class kind) Return the next offset after start but less than or equal to limit where a span of the specified type begins or ends.","void removeSpan(Object what) Remove the specified markup object from the buffer.","SpannableStringBuilder replace(int start, int end, CharSequence tb) Convenience for replace(st, en, text, 0, text.length())","SpannableStringBuilder replace(int start, int end, CharSequence tb, int tbstart, int tbend) Replaces the specified range (st\u2026en) of text in this Editable with a copy of the slice start\u2026end from source.","void setFilters(InputFilter[] filters) Sets the series of filters that will be called in succession whenever the text of this Editable is changed, each of which has the opportunity to limit or transform the text that is being inserted.","void setSpan(Object what, int start, int end, int flags) Mark the specified range of text with the specified object.","CharSequence subSequence(int start, int end) Return a new CharSequence containing a copy of the specified range of this buffer, including the overlapping spans.","String toString() Return a String containing a copy of the chars in this buffer.","static SpannableStringBuilder valueOf(CharSequence source)","[Expand] Inherited Methods","From class java.lang.Object Object clone() Creates and returns a copy of this Object. boolean equals(Object o) Compares this instance with the specified object and indicates if they are equal. void finalize() Invoked when the garbage collector has detected that this instance is no longer reachable. final Class<?> getClass() Returns the unique instance of Class that represents this object's class. int hashCode() Returns an integer hash code for this object. final void notify() Causes a thread which is waiting on this object's monitor (by means of calling one of the wait() methods) to be woken up. final void notifyAll() Causes all threads which are waiting on this object's monitor (by means of calling one of the wait() methods) to be woken up. String toString() Returns a string containing a concise, human-readable description of this object. final void wait() Causes the calling thread to wait until another thread calls the notify() or notifyAll() method of this object. final void wait(long millis, int nanos) Causes the calling thread to wait until another thread calls the notify() or notifyAll() method of this object or until the specified timeout expires. final void wait(long millis) Causes the calling thread to wait until another thread calls the notify() or notifyAll() method of this object or until the specified timeout expires.","Object clone() Creates and returns a copy of this Object.","boolean equals(Object o) Compares this instance with the specified object and indicates if they are equal.","void finalize() Invoked when the garbage collector has detected that this instance is no longer reachable.","final Class<?> getClass() Returns the unique instance of Class that represents this object's class.","int hashCode() Returns an integer hash code for this object.","final void notify() Causes a thread which is waiting on this object's monitor (by means of calling one of the wait() methods) to be woken up.","final void notifyAll() Causes all threads which are waiting on this object's monitor (by means of calling one of the wait() methods) to be woken up.","String toString() Returns a string containing a concise, human-readable description of this object.","final void wait() Causes the calling thread to wait until another thread calls the notify() or notifyAll() method of this object.","final void wait(long millis, int nanos) Causes the calling thread to wait until another thread calls the notify() or notifyAll() method of this object or until the specified timeout expires.","final void wait(long millis) Causes the calling thread to wait until another thread calls the notify() or notifyAll() method of this object or until the specified timeout expires.","From interface android.text.Editable abstract Editable append(CharSequence text) Convenience for replace(length(), length(), text, 0, text.length()) abstract Editable append(CharSequence text, int start, int end) Convenience for replace(length(), length(), text, start, end) abstract Editable append(char text) Convenience for append(String.valueOf(text)). abstract void clear() Convenience for replace(0, length(), \"\", 0, 0) abstract void clearSpans() Removes all spans from the Editable, as if by calling removeSpan(Object) on each of them. abstract Editable delete(int st, int en) Convenience for replace(st, en, \"\", 0, 0) abstract InputFilter[] getFilters() Returns the array of input filters that are currently applied to changes to this Editable. abstract Editable insert(int where, CharSequence text, int start, int end) Convenience for replace(where, where, text, start, end) abstract Editable insert(int where, CharSequence text) Convenience for replace(where, where, text, 0, text.length()); abstract Editable replace(int st, int en, CharSequence source, int start, int end) Replaces the specified range (st\u2026en) of text in this Editable with a copy of the slice start\u2026end from source. abstract Editable replace(int st, int en, CharSequence text) Convenience for replace(st, en, text, 0, text.length()) abstract void setFilters(InputFilter[] filters) Sets the series of filters that will be called in succession whenever the text of this Editable is changed, each of which has the opportunity to limit or transform the text that is being inserted.","abstract Editable append(CharSequence text) Convenience for replace(length(), length(), text, 0, text.length())","abstract Editable append(CharSequence text, int start, int end) Convenience for replace(length(), length(), text, start, end)","abstract Editable append(char text) Convenience for append(String.valueOf(text)).","abstract void clear() Convenience for replace(0, length(), \"\", 0, 0)","abstract void clearSpans() Removes all spans from the Editable, as if by calling removeSpan(Object) on each of them.","abstract Editable delete(int st, int en) Convenience for replace(st, en, \"\", 0, 0)","abstract InputFilter[] getFilters() Returns the array of input filters that are currently applied to changes to this Editable.","abstract Editable insert(int where, CharSequence text, int start, int end) Convenience for replace(where, where, text, start, end)","abstract Editable insert(int where, CharSequence text) Convenience for replace(where, where, text, 0, text.length());","abstract Editable replace(int st, int en, CharSequence source, int start, int end) Replaces the specified range (st\u2026en) of text in this Editable with a copy of the slice start\u2026end from source.","abstract Editable replace(int st, int en, CharSequence text) Convenience for replace(st, en, text, 0, text.length())","abstract void setFilters(InputFilter[] filters) Sets the series of filters that will be called in succession whenever the text of this Editable is changed, each of which has the opportunity to limit or transform the text that is being inserted.","From interface android.text.GetChars abstract void getChars(int start, int end, char[] dest, int destoff) Exactly like String.getChars(): copy chars start through end - 1 from this CharSequence into dest beginning at offset destoff.","abstract void getChars(int start, int end, char[] dest, int destoff) Exactly like String.getChars(): copy chars start through end - 1 from this CharSequence into dest beginning at offset destoff.","From interface android.text.Spannable abstract void removeSpan(Object what) Remove the specified object from the range of text to which it was attached, if any. abstract void setSpan(Object what, int start, int end, int flags) Attach the specified markup object to the range start\u2026end of the text, or move the object to that range if it was already attached elsewhere.","abstract void removeSpan(Object what) Remove the specified object from the range of text to which it was attached, if any.","abstract void setSpan(Object what, int start, int end, int flags) Attach the specified markup object to the range start\u2026end of the text, or move the object to that range if it was already attached elsewhere.","From interface android.text.Spanned abstract int getSpanEnd(Object tag) Return the end of the range of text to which the specified markup object is attached, or -1 if the object is not attached. abstract int getSpanFlags(Object tag) Return the flags that were specified when setSpan(Object, int, int, int) was used to attach the specified markup object, or 0 if the specified object has not been attached. abstract int getSpanStart(Object tag) Return the beginning of the range of text to which the specified markup object is attached, or -1 if the object is not attached. abstract <T> T[] getSpans(int start, int end, Class<T> type) Return an array of the markup objects attached to the specified slice of this CharSequence and whose type is the specified type or a subclass of it. abstract int nextSpanTransition(int start, int limit, Class type) Return the first offset greater than or equal to start where a markup object of class type begins or ends, or limit if there are no starts or ends greater than or equal to start but less than limit.","abstract int getSpanEnd(Object tag) Return the end of the range of text to which the specified markup object is attached, or -1 if the object is not attached.","abstract int getSpanFlags(Object tag) Return the flags that were specified when setSpan(Object, int, int, int) was used to attach the specified markup object, or 0 if the specified object has not been attached.","abstract int getSpanStart(Object tag) Return the beginning of the range of text to which the specified markup object is attached, or -1 if the object is not attached.","abstract <T> T[] getSpans(int start, int end, Class<T> type) Return an array of the markup objects attached to the specified slice of this CharSequence and whose type is the specified type or a subclass of it.","abstract int nextSpanTransition(int start, int limit, Class type) Return the first offset greater than or equal to start where a markup object of class type begins or ends, or limit if there are no starts or ends greater than or equal to start but less than limit.","From interface java.lang.Appendable abstract Appendable append(CharSequence csq) Appends the character sequence csq. abstract Appendable append(CharSequence csq, int start, int end) Appends a subsequence of csq. abstract Appendable append(char c) Appends the specified character.","abstract Appendable append(CharSequence csq) Appends the character sequence csq.","abstract Appendable append(CharSequence csq, int start, int end) Appends a subsequence of csq.","abstract Appendable append(char c) Appends the specified character.","From interface java.lang.CharSequence abstract char charAt(int index) Returns the character at index. abstract int length() Returns the number of characters in this sequence. abstract CharSequence subSequence(int start, int end) Returns a CharSequence from the start index (inclusive) to the end index (exclusive) of this sequence. abstract String toString() Returns a string with the same characters in the same order as in this sequence.","abstract char charAt(int index) Returns the character at index.","abstract int length() Returns the number of characters in this sequence.","abstract CharSequence subSequence(int start, int end) Returns a CharSequence from the start index (inclusive) to the end index (exclusive) of this sequence.","abstract String toString() Returns a string with the same characters in the same order as in this sequence."],"package":"android.text","constants":["[Expand] Inherited Constants","From interface android.text.Spanned int SPAN_COMPOSING This flag is set on spans that are being used to apply temporary styling information on the composing text of an input method, so that they can be found and removed when the composing text is being replaced. int SPAN_EXCLUSIVE_EXCLUSIVE Spans of type SPAN_EXCLUSIVE_EXCLUSIVE do not expand to include text inserted at either their starting or ending point. int SPAN_EXCLUSIVE_INCLUSIVE Non-0-length spans of type SPAN_EXCLUSIVE_INCLUSIVE expand to include text inserted at their ending point but not at their starting point. int SPAN_INCLUSIVE_EXCLUSIVE Non-0-length spans of type SPAN_INCLUSIVE_EXCLUSIVE expand to include text inserted at their starting point but not at their ending point. int SPAN_INCLUSIVE_INCLUSIVE Spans of type SPAN_INCLUSIVE_INCLUSIVE expand to include text inserted at either their starting or ending point. int SPAN_INTERMEDIATE This flag will be set for intermediate span changes, meaning there is guaranteed to be another change following it. int SPAN_MARK_MARK 0-length spans with type SPAN_MARK_MARK behave like text marks: they remain at their original offset when text is inserted at that offset. int SPAN_MARK_POINT SPAN_MARK_POINT is a synonym for SPAN_INCLUSIVE_INCLUSIVE. int SPAN_PARAGRAPH SPAN_PARAGRAPH behaves like SPAN_INCLUSIVE_EXCLUSIVE (SPAN_MARK_MARK), except that if either end of the span is at the end of the buffer, that end behaves like _POINT instead (so SPAN_INCLUSIVE_INCLUSIVE if it starts in the middle and ends at the end, or SPAN_EXCLUSIVE_INCLUSIVE if it both starts and ends at the end). int SPAN_POINT_MARK SPAN_POINT_MARK is a synonym for SPAN_EXCLUSIVE_EXCLUSIVE. int SPAN_POINT_MARK_MASK Bitmask of bits that are relevent for controlling point/mark behavior of spans. int SPAN_POINT_POINT 0-length spans with type SPAN_POINT_POINT behave like cursors: they are pushed forward by the length of the insertion when text is inserted at their offset. int SPAN_PRIORITY The bits specified by the SPAN_PRIORITY bitmap determine the order of change notifications -- higher numbers go first. int SPAN_PRIORITY_SHIFT The bits numbered just above SPAN_PRIORITY_SHIFT determine the order of change notifications -- higher numbers go first. int SPAN_USER The bits specified by the SPAN_USER bitfield are available for callers to use to store scalar data associated with their span object. int SPAN_USER_SHIFT The bits numbered SPAN_USER_SHIFT and above are available for callers to use to store scalar data associated with their span object.","int SPAN_COMPOSING This flag is set on spans that are being used to apply temporary styling information on the composing text of an input method, so that they can be found and removed when the composing text is being replaced.","int SPAN_EXCLUSIVE_EXCLUSIVE Spans of type SPAN_EXCLUSIVE_EXCLUSIVE do not expand to include text inserted at either their starting or ending point.","int SPAN_EXCLUSIVE_INCLUSIVE Non-0-length spans of type SPAN_EXCLUSIVE_INCLUSIVE expand to include text inserted at their ending point but not at their starting point.","int SPAN_INCLUSIVE_EXCLUSIVE Non-0-length spans of type SPAN_INCLUSIVE_EXCLUSIVE expand to include text inserted at their starting point but not at their ending point.","int SPAN_INCLUSIVE_INCLUSIVE Spans of type SPAN_INCLUSIVE_INCLUSIVE expand to include text inserted at either their starting or ending point.","int SPAN_INTERMEDIATE This flag will be set for intermediate span changes, meaning there is guaranteed to be another change following it.","int SPAN_MARK_MARK 0-length spans with type SPAN_MARK_MARK behave like text marks: they remain at their original offset when text is inserted at that offset.","int SPAN_MARK_POINT SPAN_MARK_POINT is a synonym for SPAN_INCLUSIVE_INCLUSIVE.","int SPAN_PARAGRAPH SPAN_PARAGRAPH behaves like SPAN_INCLUSIVE_EXCLUSIVE (SPAN_MARK_MARK), except that if either end of the span is at the end of the buffer, that end behaves like _POINT instead (so SPAN_INCLUSIVE_INCLUSIVE if it starts in the middle and ends at the end, or SPAN_EXCLUSIVE_INCLUSIVE if it both starts and ends at the end).","int SPAN_POINT_MARK SPAN_POINT_MARK is a synonym for SPAN_EXCLUSIVE_EXCLUSIVE.","int SPAN_POINT_MARK_MASK Bitmask of bits that are relevent for controlling point/mark behavior of spans.","int SPAN_POINT_POINT 0-length spans with type SPAN_POINT_POINT behave like cursors: they are pushed forward by the length of the insertion when text is inserted at their offset.","int SPAN_PRIORITY The bits specified by the SPAN_PRIORITY bitmap determine the order of change notifications -- higher numbers go first.","int SPAN_PRIORITY_SHIFT The bits numbered just above SPAN_PRIORITY_SHIFT determine the order of change notifications -- higher numbers go first.","int SPAN_USER The bits specified by the SPAN_USER bitfield are available for callers to use to store scalar data associated with their span object.","int SPAN_USER_SHIFT The bits numbered SPAN_USER_SHIFT and above are available for callers to use to store scalar data associated with their span object."],"class":"SpannableStringBuilder","constructors":[],"fields":[]}