package com.pseudosudostudios.jdoc;import android.app.ProgressDialog;import android.content.Context;import android.content.Intent;import android.os.AsyncTask;import android.support.annotation.NonNull;import android.util.Log;import org.json.JSONException;import org.json.JSONObject;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.Arrays;import java.util.List;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import data.FileInfoFactory;/** * Created by Ben on 11/17/2014. * Copyright (c) 2014 Pseudo Sudo Studios */public class DataLoader extends AsyncTask<Void, Integer, Void> {    //private constants    private static final String TAG = DataLoader.class.getSimpleName(); //For logs    private static final boolean LOG_INDIV = true; //Log individual parse times    private static final int DELTA = 13; //Files to parse before posting an update on main thread    private static final String parent = "data-files";    private Context context;    private ProgressDialog dialog; //Where to post updates    boolean publishProgress;    private final String[] files;    private final boolean LOG_ERROR = false;    public DataLoader(Context context, ProgressDialog dialog, int style) {        String[] files1;        this.context = context;        //Dialog to post updates to        this.dialog = dialog;        try {            files1 = context.getAssets().list(parent);            files1 = Arrays.copyOf(files1, 100); //TODO remove            publishProgress = style == ProgressDialog.STYLE_HORIZONTAL;        } catch (IOException e) {            publishProgress = false;            files1 = new String[0];            e.printStackTrace();        }        files = files1;    }    @Override    protected void onPreExecute() {        super.onPreExecute();        if (publishProgress)            dialog.setMax(files.length);    }    @Override    protected Void doInBackground(Void... voids) {        long start = System.currentTimeMillis();        try {            SmartDesignator executorService = new SmartDesignator();            long submitStart = System.currentTimeMillis();            int count = 0;            for (final String file : files) {                executorService.smartDesignation(++count, file);            }            Log.i("DataLoader", "Submit time: " +                    ((System.currentTimeMillis() - submitStart) / 1000D));            executorService.shutdown(); //No more can be scheduled            if (executorService.awaitTermination(45, TimeUnit.SECONDS)) {                Log.i(TAG, "Executor finished, parsed: " + files.length);            } else {                Log.w(TAG, "Executor forced stop");                executorService.shutdownNow(); //Force termination            }        } catch (Exception e) {            if (LOG_ERROR)                e.printStackTrace();        }        FileInfoFactory.sortPackages(); //sort when done        Log.i("DataLoader", "Parse time: " +                ((System.currentTimeMillis() - start) / 1000D));        return null;    }    private double loadData(InputStream stream, String name) {        try {            long start = System.currentTimeMillis();            BufferedReader reader = new BufferedReader(                    new InputStreamReader(stream));            StringBuilder buffer = new StringBuilder();            while (reader.ready() && !Thread.interrupted())                buffer.append(reader.readLine());            reader.close();            String jString = buffer.toString();            JSONObject jObj = new JSONObject(jString);            FileInfoFactory.parseFile(jObj);            double d = (System.currentTimeMillis() - start) / 1000D;            if (LOG_INDIV)                Log.i(TAG, String.format("%s parse time: %.03f", name, d));            return d;        } catch (IOException e) {            e.printStackTrace();        } catch (JSONException e) {            e.printStackTrace();        }        return -1;    }    @Override    protected void onProgressUpdate(Integer... values) {        super.onProgressUpdate(values);        dialog.incrementProgressBy(DELTA);    }    @Override    protected void onPostExecute(Void aVoid) {        super.onPostExecute(aVoid);        dialog.cancel();        context.startActivity(new Intent(context, ExplorerActivity.class));    }    private class SmartDesignator {        private static final int THRESHOLD = 10 * 1000; //~10 kB        ExecutorService cached;        ExecutorService fixed;        public SmartDesignator() {            cached = Executors.newCachedThreadPool();            fixed = Executors.newFixedThreadPool(5);        }        public void shutdown() {            cached.shutdown();            fixed.shutdown();        }        @NonNull        public List<Runnable> shutdownNow() {            List<Runnable> list = cached.shutdownNow();            list.addAll(fixed.shutdownNow());            return list;        }        public boolean isShutdown() {            return fixed.isShutdown() && cached.isShutdown();        }        public boolean isTerminated() {            return fixed.isTerminated() && cached.isTerminated();        }        /**         * Attempt to wait for all managed ExecutorServices to terminate.         * Each service will try to wait for the total amount of time,         * therefore the total maximum wait is 2*<code>l</code>         */        public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {            boolean f = false;            boolean c = false;            InterruptedException exception = null;            try {                f = fixed.awaitTermination(l, timeUnit);            } catch (InterruptedException e) {                exception = e;            }            c = cached.awaitTermination(l, timeUnit);            if (exception != null)                throw exception;            return f && c;        }        public void smartDesignation(int number, String currentFile) throws IOException {            if (!currentFile.endsWith(".json"))                return;            InputStream stream = context.getAssets().open(new File(parent, currentFile).toString());            int length = stream.available();            ExecutorService service = length >= THRESHOLD ? fixed : cached;            service.execute(new ParseRunnable(number, currentFile, stream));        }        private class ParseRunnable implements Runnable {            private final int fileNumber;            private final InputStream file;            private final String fileName;            public ParseRunnable(int num, String n, InputStream name) {                this.fileNumber = num;                this.fileName = n;                this.file = name;            }            @Override            public void run() {                try {                    if (Thread.interrupted())                        return;                    if (Thread.interrupted())                        return;                    loadData(file, fileName);                    if (publishProgress && fileNumber % DELTA == 0)                        publishProgress(fileNumber);                    try {                        file.close();                    } catch (Exception e) {                        //Do nothing                    }                } catch (Exception e) {                    if (LOG_ERROR)                        e.printStackTrace();                }            }        }    }}