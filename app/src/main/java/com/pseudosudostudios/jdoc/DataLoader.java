package com.pseudosudostudios.jdoc;import android.app.ProgressDialog;import android.content.Context;import android.content.Intent;import android.os.AsyncTask;import android.support.annotation.NonNull;import android.util.Log;import org.json.JSONException;import org.json.JSONObject;import java.io.BufferedReader;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.Arrays;import java.util.List;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import data.FileInfoFactory;public class DataLoader extends AsyncTask<Void, Integer, Void> {    //private constants    private static final String TAG = DataLoader.class.getSimpleName(); //For logs    private static final boolean LOG_EACH_TIME = false; //Log individual parse times    private static final int DELTA = 7; //Files to parse before posting an update on main thread    private static final String parent = "data-files";    private final boolean LOG_ERROR = false;    private Context context; //Hook into large variety of Android APIs like I/O    private ProgressDialog dialog; //Where to post updates    //If the dialog is not of HORIZONTAL style, don't publish updates.    //They will not be visible to the user. Since the call to publish the updates and the actual    //update is run on different threads, this is more efficient than a simple method call.    private boolean publishProgress;    //Files to be parsed.    private final String[] files;    public DataLoader(Context context, ProgressDialog dialog, int style) {        String[] files1;        this.context = context;        //Dialog to post updates to        this.dialog = dialog;        try {            files1 = context.getAssets().list(parent);            publishProgress = style == ProgressDialog.STYLE_HORIZONTAL;        } catch (IOException e) {            publishProgress = false;            files1 = new String[0];            e.printStackTrace();        }        files = files1;    }    //Runs on UI Thread to handle initial set up of progress dialog    @Override    protected void onPreExecute() {        super.onPreExecute();        if (publishProgress)            dialog.setMax(files.length);    }    @Override    /**Runs in background (non-ui thread) and handles sending all items to the executorService.*/    protected Void doInBackground(Void... voids) {        long start = System.currentTimeMillis();        try {            SmartDesignator executorService = new SmartDesignator();            long submitStart = System.currentTimeMillis();            int count = 0;            for (final String file : files) {                executorService.smartDesignation(++count, file);            }            Log.i("DataLoader", "Submit time: " +                    ((System.currentTimeMillis() - submitStart) / 1000D));            executorService.shutdown(); //No more can be scheduled            if (executorService.awaitTermination(45, TimeUnit.SECONDS)) {                Log.i(TAG, "Executor finished, parsed: " + files.length);            } else {                Log.w(TAG, "Executor did finish in time stop");                executorService.shutdownNow(); //Force termination            }        } catch (Exception e) {            if (LOG_ERROR)                e.printStackTrace();        }        FileInfoFactory.sortPackages(); //sort when done        Log.i("DataLoader", "Parse time: " +                ((System.currentTimeMillis() - start) / 1000D));        return null;    }    /**     * Loads the data file. Since the native IO methods return an InputStream, that is given as a     * parameter. The name of the file is passed for logging only.     *     * @param stream InputStream of the file     * @param name   the name of the file     * @return the time to parse the file     */    private double loadData(InputStream stream, String name) {        if (!containsUniqueChar(name, '.') || name.contains("support.v"))            return -1;        try {            long start = System.currentTimeMillis();            BufferedReader reader = new BufferedReader(                    new InputStreamReader(stream));            StringBuilder buffer = new StringBuilder();            while (reader.ready() && !Thread.interrupted())                buffer.append(reader.readLine());            reader.close();            String jString = buffer.toString();            JSONObject jObj = new JSONObject(jString);            FileInfoFactory.parseFile(jObj);            double d = (System.currentTimeMillis() - start) / 1000D;            if (LOG_EACH_TIME)                Log.i(TAG, String.format("%s parse time: %.03f", name, d));            stream.close(); //Stream will no longer be used            return d;        } catch (IOException e) {            e.printStackTrace();        } catch (JSONException e) {            e.printStackTrace();        }        return -1;    }    private boolean containsUniqueChar(String name, char c) {        boolean seen = false;        char[] chars = name.toCharArray();        for (char current : chars) {            if (current == c) {                if (seen)                    return false;                else                    seen = true;            }        }        return seen;    }    @Override    protected void onProgressUpdate(Integer... values) {        super.onProgressUpdate(values);        dialog.incrementProgressBy(DELTA);    }    @Override    /**Once finished, launch the main Activity (Screen)*/    protected void onPostExecute(Void aVoid) {        super.onPostExecute(aVoid);        dialog.cancel();        context.startActivity(new Intent(context, ExplorerActivity.class));    }    /**     * A subset of java.util.concurrent.ExecutorService that intelligently delegates the parsing     * of a file based on file size. Longer (bigger) files are done on a fixed-number thread     * pool, smaller files in a cached thread pool.     * Each supported calls the corresponding method of the relevant     * java.util.concurrent.ExecutorService     */    private class SmartDesignator {        private static final int THRESHOLD = 12 * 1000; //~12 kB        ExecutorService cached;        ExecutorService fixed;        public SmartDesignator() {            cached = Executors.newCachedThreadPool();            fixed = Executors.newFixedThreadPool(5);        }        public void shutdown() {            cached.shutdown();            fixed.shutdown();        }        @NonNull        public List<Runnable> shutdownNow() {            List<Runnable> list = cached.shutdownNow();            list.addAll(fixed.shutdownNow());            return list;        }        public boolean isShutdown() {            return fixed.isShutdown() && cached.isShutdown();        }        public boolean isTerminated() {            return fixed.isTerminated() && cached.isTerminated();        }        /**         * Attempt to wait for all managed ExecutorServices to terminate.         * Each service will try to wait for the total amount of time,         * therefore the total maximum wait is 2*<code>l</code>         */        public boolean awaitTermination(long l, TimeUnit timeUnit) throws InterruptedException {            boolean f = false;            boolean c = false;            InterruptedException exception = null;            try {                f = fixed.awaitTermination(l, timeUnit);            } catch (InterruptedException e) {                exception = e;            }            c = cached.awaitTermination(l, timeUnit);            if (exception != null)                throw exception;            return f && c;        }        /**         * Replaces execute of java.util.concurrent.ExecutorService to handle some         * additional processing.         */        public void smartDesignation(int number, String currentFile) throws IOException {            if (!currentFile.endsWith(".json"))                return;            InputStream stream = context.getAssets().open(new File(parent, currentFile).toString());            int length = stream.available();            ExecutorService service = length >= THRESHOLD ? fixed : cached;            service.execute(new ParseRunnable(number, currentFile, stream));        }        private class ParseRunnable implements Runnable {            private final int fileNumber;            private final InputStream file;            private final String fileName;            public ParseRunnable(int num, String n, InputStream name) {                this.fileNumber = num;                this.fileName = n;                this.file = name;            }            @Override            public void run() {                try {                    loadData(file, fileName);                    if (publishProgress && fileNumber % DELTA == 0) //update on every DELTA                        publishProgress();                    try {                        file.close();                    } catch (Exception e) {                        //Do nothing                    }                } catch (Exception e) {                    if (LOG_ERROR)                        e.printStackTrace();                }            }        }    }}